package com.jb.thickclient;

import burp.*;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.util.List;
import java.util.*;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

public class BurpExtender implements IBurpExtender, ITab, IHttpListener, IProxyListener, IMessageEditorController {

    // Burp
    private IBurpExtenderCallbacks callbacks;
    private IExtensionHelpers helpers;

    // UI
    private JPanel root;
    private JTextField hostRegexField;
    private JTextField portCsvField;
    private JTextField mimeRegexField;
    private JCheckBox onlyMatchChk;
    private JButton applyBtn;
    private JButton genPacBtn;
    private JTextArea logArea;

    // Filters (compiled)
    private Pattern hostPattern = Pattern.compile(".*");
    private Set<Integer> allowedPorts = new HashSet<>(Arrays.asList(80, 443, 8080, 8443));
    private Pattern mimePattern = Pattern.compile("^(application/json|application/xml|text/.*|application/octet-stream)$");

    private static final String TAG = "[THC4M3]";

    // ---------- IBurpExtender ----------
    @Override
    public void registerExtenderCallbacks(IBurpExtenderCallbacks cb) {
        this.callbacks = cb;
        this.helpers = cb.getHelpers();
        cb.setExtensionName("THC4M3");

        // UI first (never block)
        try {
            initUI();
            cb.addSuiteTab(this);
        } catch (Throwable t) {
            safePrint("UI init failed: " + t);
        }

        // listeners & settings (guarded)
        try {
            cb.registerHttpListener(this);
            cb.registerProxyListener(this);
            restoreSettings();
            safePrint("Loaded. Adjust filters and click Apply.");
        } catch (Throwable t) {
            safeWarn("Bootstrap/listeners failed: " + t);
        }
    }

    // ---------- ITab ----------
    @Override public String getTabCaption() { return "THC4M3"; }
    @Override public Component getUiComponent() { return root; }

    // ---------- IHttpListener ----------
    @Override
    public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {
        try {
            IHttpService svc = messageInfo.getHttpService();
            if (!hostAllowed(svc) || !portAllowed(svc)) {
                return;
            }

            if (messageIsRequest) {
                IRequestInfo ri = helpers.analyzeRequest(messageInfo);
                // Optional: mark matching requests
                messageInfo.setComment(TAG + " host/port match");
                if (onlyMatchChk.isSelected()) {
                    logRow("→ " + svc.getHost() + ":" + svc.getPort() + " " + ri.getMethod());
                }
            } else {
                IResponseInfo rr = helpers.analyzeResponse(messageInfo.getResponse());
                if (responseMimeAllowed(messageInfo)) {
                    messageInfo.setComment(TAG + " mime match: " + effectiveMime(rr));
                    if (onlyMatchChk.isSelected()) {
                        logRow("← " + svc.getHost() + ":" + svc.getPort() + " " + rr.getStatusCode());
                    }
                }
            }
        } catch (Throwable t) {
            safeWarn("processHttpMessage: " + t);
        }
    }

    // ---------- IProxyListener ----------
    @Override public void processProxyMessage(boolean messageIsRequest, IInterceptedProxyMessage message) {
        // No-op for now (all logic handled in IHttpListener)
    }

    // ---------- IMessageEditorController (placeholders for future UI binding) ----------
    @Override public IHttpService getHttpService() { return null; }
    @Override public byte[] getRequest() { return new byte[0]; }
    @Override public byte[] getResponse() { return new byte[0]; }

    // ---------- UI ----------
    private void initUI() {
        root = new JPanel(new BorderLayout());
        root.setBorder(new EmptyBorder(10,10,10,10));

        JPanel form = new JPanel(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.insets = new Insets(6,6,6,6);
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1.0;

        hostRegexField = new JTextField(".*");
        portCsvField   = new JTextField("80,443,8080,8443");
        mimeRegexField = new JTextField("^(application/json|application/xml|text/.*|application/octet-stream)$");
        onlyMatchChk   = new JCheckBox("Show/annotate only matching traffic", false);

        int row = 0;
        addRow(form, c, row++, "Host allow (regex)", hostRegexField);
        addRow(form, c, row++, "Ports allow (csv)", portCsvField);
        addRow(form, c, row++, "MIME allow (regex)", mimeRegexField);
        c.gridx = 1; c.gridy = row++; form.add(onlyMatchChk, c);

        JPanel buttons = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        applyBtn = new JButton("Apply Filters");
        genPacBtn = new JButton("Generate PAC…");
        buttons.add(applyBtn);
        buttons.add(genPacBtn);
        c.gridx = 1; c.gridy = row++; form.add(buttons, c);

        logArea = new JTextArea(10, 80);
        logArea.setEditable(false);
        JScrollPane logScroll = new JScrollPane(logArea);

        root.add(form, BorderLayout.NORTH);
        root.add(logScroll, BorderLayout.CENTER);

        // Actions
        applyBtn.addActionListener(e -> {
            try {
                saveSettings();
                recompilePatternsAndPorts();
                safePrint("Filters applied.");
            } catch (Throwable t) {
                safeWarn("Apply failed: " + t.getMessage());
            }
        });

        genPacBtn.addActionListener(e -> {
            try {
                String rx = hostRegexField.getText().trim();
                String pac = PacBuilder.buildSelectivePac("127.0.0.1", 8080, rx);
                Toolkit.getDefaultToolkit().getSystemClipboard()
                        .setContents(new StringSelection(pac), null);
                safePrint("PAC copied to clipboard.");
            } catch (Throwable t) {
                safeWarn("PAC generation failed: " + t.getMessage());
            }
        });
    }

    private void addRow(JPanel p, GridBagConstraints c, int row, String label, JComponent field) {
        c.gridx = 0; c.gridy = row; c.weightx = 0.0;
        p.add(new JLabel(label), c);
        c.gridx = 1; c.gridy = row; c.weightx = 1.0;
        p.add(field, c);
    }

    // ---------- Settings ----------
    private void saveSettings() {
        callbacks.saveExtensionSetting("hostRegex", hostRegexField.getText());
        callbacks.saveExtensionSetting("portCsv",   portCsvField.getText());
        callbacks.saveExtensionSetting("mimeRegex", mimeRegexField.getText());
        callbacks.saveExtensionSetting("onlyMatch", Boolean.toString(onlyMatchChk.isSelected()));
    }

    private void restoreSettings() {
        String host = nvl(callbacks.loadExtensionSetting("hostRegex"), hostRegexField.getText());
        String port = nvl(callbacks.loadExtensionSetting("portCsv"),   portCsvField.getText());
        String mime = nvl(callbacks.loadExtensionSetting("mimeRegex"), mimeRegexField.getText());
        boolean only = Boolean.parseBoolean(nvl(callbacks.loadExtensionSetting("onlyMatch"), "false"));

        hostRegexField.setText(host);
        portCsvField.setText(port);
        mimeRegexField.setText(mime);
        onlyMatchChk.setSelected(only);
        recompilePatternsAndPorts();
    }

    private String nvl(String v, String d) { return (v == null || v.isEmpty()) ? d : v; }

    private void recompilePatternsAndPorts() {
        try {
            hostPattern = Pattern.compile(hostRegexField.getText().trim());
        } catch (PatternSyntaxException e) {
            safeWarn("Bad host regex, defaulting to .* : " + e.getMessage());
            hostPattern = Pattern.compile(".*");
        }

        allowedPorts.clear();
        for (String s : portCsvField.getText().split(",")) {
            s = s.trim();
            if (s.isEmpty()) continue;
            try { allowedPorts.add(Integer.parseInt(s)); }
            catch (NumberFormatException ignore) { /* skip bad entries */ }
        }
        if (allowedPorts.isEmpty()) allowedPorts.addAll(Arrays.asList(80,443,8080,8443));

        try {
            mimePattern = Pattern.compile(mimeRegexField.getText().trim());
        } catch (PatternSyntaxException e) {
            safeWarn("Bad MIME regex, using default: " + e.getMessage());
            mimePattern = Pattern.compile("^(application/json|application/xml|text/.*|application/octet-stream)$");
        }
    }

    // ---------- Predicates ----------
    private boolean hostAllowed(IHttpService svc) {
        if (svc == null) return false;
        String host = svc.getHost() == null ? "" : svc.getHost();
        return hostPattern.matcher(host).find();
    }

    private boolean portAllowed(IHttpService svc) {
        return svc != null && allowedPorts.contains(svc.getPort());
    }

    private boolean responseMimeAllowed(IHttpRequestResponse msg) {
        IResponseInfo ri = helpers.analyzeResponse(msg.getResponse());
        String mime = effectiveMime(ri);
        return mimePattern.matcher(mime == null ? "" : mime).find();
    }

    private String effectiveMime(IResponseInfo ri) {
        String inferred = nvl(ri.getStatedMimeType(), "");
        if (inferred.isEmpty() || "unknown".equalsIgnoreCase(inferred)) {
            inferred = nvl(ri.getInferredMimeType(), "");
        }
        return inferred;
    }

    // ---------- Logging (safe for EDT) ----------
    private void logRow(String s) {
        SwingUtilities.invokeLater(() -> {
            logArea.append(s + "\n");
            logArea.setCaretPosition(logArea.getDocument().getLength());
        });
    }
    private void safePrint(String s) { callbacks.printOutput(TAG + " " + s); logRow(s); }
    private void safeWarn(String s)  { callbacks.printError (TAG + " " + s); logRow("WARN: " + s); }
}
